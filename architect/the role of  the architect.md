## The role of the architect
架构师不是一个头衔或级别;这是一个角色。架构师的主要职责是为需要构建的内容定义一个蓝图，并确保团队的其他成员有足够的细节来完成工作。架构师在执行过程中指导团队的其他成员进行此设计，同时管理与所有涉众的持续对话。
架构师也是开发人员和非技术涉众的参谋，包括什么是可能的，什么是不可能的，以及v的成本影响(工作、权衡、技术债务，等等)

不编写代码也可以完成架构师的工作。但在我个人看来，这导致了设计的缺陷。除非我们了解底层细节、约束条件和复杂性，否则我们不可能想出一个伟大的设计。许多组织轻视架构师的角色，因为他们对架构师的负面经验是，他们从象牙塔中指挥，不参与构建可工作软件的实际任务。但是，另一方面，没有蓝图可能导致狂野的代码基础，在工作和产品质量方面，小的变化会导致非直观的效果。

### 本质上，架构师需要向团队提供的一些东西

在当今的敏捷世界中，需求分析几乎是一项正在进行的活动。但是架构师帮助团队导航需求，并决定要做什么(这可能并不总是那么明显)。

### 正北
除了需求之外，我们还需要定义系统的关键工程原则。  
- **高层次设计**：将系统分解为高级组件，这是产品和代码在产品开发生命周期的每个阶段都需要遵循的蓝图。
- **质量属性**：我们想要高质量的代码，这意味着如果没有单元测试和90%的代码覆盖率，就不允许进行代码检查。
    ```
    例如: 测试代码覆盖率
    //生成代码覆盖率文件out
    go test ./... -coverprofile out
    //在浏览器打开代码覆盖率文件
    go tool cover -html out
    ```
- **生产线速度**：产品在时间上有一个有限的值，并且为了确保有高的开发人员生产力，团队应该构建持续集成/持续部署(CICD)从一开始就是管道。

- **A/B 测试**：每个功能都应该有一个标志，这样它只能显示给一定百分比的用户。

这些通用的指导方针或原则，以及高级设计，帮助团队在每个阶段做出决策。

### 技术选择
一旦我们有了一个架构，我们需要定义一些事情，例如编程语言和框架，并为各个构造选择源代码还是构建。这包括数据库选择、供应商选择、技术策略、部署环境、升级策略等等。这些因素加在一起通常可以让选择简单的事情成为一场彻底的噩梦，最后这些技术必须很好的协同工作。

#### 教练和辅导
开发此类产品的开发人员经常需要，并寻求，指导和辅导他们的即时交付物之外。他们的核心目标之一是学习、讨论困难的问题，并提高自己的技能。没有一个促进这种互动的环境会导致挫折和开发者的流失。

在管理产品的技术管理时，很多时候，架构师需要扮演开发人员的教练和指导者角色。这可能涉及技术反馈会议和职业咨询。

### 目标状态和当前状态
当架构师和开发者拿到需求时，他们经常想出漂亮而优雅的设计。但是一般来说，一旦项目开始，团队就会面临快速交付的压力。业务涉众想要一些快速的东西(最小可行而不是等待最终产品的发行。这在降低产品风险方面是有意义的，并在产品是否满足业务需求方面为团队提供了关键的反馈

但这种运营模式也有很大的成本。为了赶在最后期限前完成项目，开发者在开发项目时走了捷径。因此，即使我们在架构方面有一个干净、美丽的目标状态，现实并不会与之匹配。这种不匹配并不是错的;相反,它是自然的。但是对于团队来说，重要的是要牢记目标状态，并定义在每个s冲刺期间将产品带到目标状态的下一组小块。这意味着架构师需要与产品和工程师一起参与团队的冲刺计划。

## 软件架构

### 架构与设计
这个词通常用来指高层的东西，与低层的细节不同，而设计更多的是指低层的结构和决策。但两者是内在联系的，没有两者的协同作用，我们就不可能有好的产品。低级细节和高级结构都是同一整体的一部分。它们形成了一个连续的结构，定义了系统的形状。两者不可兼得;从最高到最低的决策是连续的。

单独从事架构和设计工作，没有中心主题和指导原则，会导致开发人员对代码库的理解就像盲人对著名寓言中的大象的理解一样。

另一方面，架构师记录低层次设计的每个方面是不实际的(或不可取的)。关键是为代码建立一个远景和指导原则，这可以作为开发人员在每个级别上做决策时的保护。

### 架构是什么样的
一年中出现了多种架构范例，但是它们都有一个关键目标:管理复杂性。我们如何将代码打包到组件中，并将这些组件作为抽象实体来推断和构建行为块?

这些组件将系统划分为多个分区，以便每个分区具有特定的关注事项和角色。每个组件都有定义良好的接口和职责，并与其他组件隔离。有了这种抽象，我们就不必担心组件的内部工作方式了。

系统分解需要是一个深思熟虑的活动。评估组件好坏有两个关键指标，即内聚性和耦合性:
- 高内聚：表示组件执行单个相关任务
- 低耦合：意味着组件之间有更低的依赖。

可以很容易地扩展一个组件，向其添加更多的功能或数据。而且，如果需要的话，它应该是完全可替换的，不会影响系统的其他部分。

## 微服务
微服务的基本概念很简单——它是一个简单的、独立的应用程序，只做一件事，并且把那件事做好。我们的目标是保持早期应用的简单性、独立性和生产力。没有一个微服务是孤岛——它是更大系统的一部分，与其他微服务一起运行和工作，以完成通常由一个大型独立应用程序处理的工作。

每个微服务都是自治的、独立的、自包含的，并且可以单独部署和扩展。微服务体系结构的目标是构建由此类微服务组成的系统。


### 微型服务的挑战——效率
```
一个立即想到的解决方案是，我们可以在同一台机器上共同托管微服务吗?要回答这个问题，首先要考虑的是语言运行时。例如，在Java中，每个微服务都需要一个单独的JVM进程来运行，以实现代码分离。然而，就资源需求而言，JVM往往相当繁重，更糟糕的是，资源需求可能激增，导致一个JVM进程由于占用资源而导致其他进程失败

因此，尽管微服务与语言无关，但有些语言比其他语言更适合和/或对微服务有更好的支持。就对微服务的友好程度而言，Golang是一个突出的语言。它在资源方面非常节约、轻量级、非常快，并且对并发性有非常好的支持，当跨多个核心运行时，这是一个强大的功能。Go还包含一个非常强大的标准库，用于编写用于通信的web服务(就像我们将要看到的那样，再往前一点)。
```

### 微服务的挑战——编程的复杂性
在大型代码库中工作时，局部推理非常重要。这指的是开发人员通过检查例程本身而不是检查整个系统来理解例程行为的能力。这是我们之前看到的一个扩展，划分是管理复杂性的关键。

众所周知，人类可以同时做7件事。在一个大系统中，可能有数百万个功能和数十亿个可能的交互，没有局部推理可能是灾难性的。

同步原语，如互斥锁和信号量，确实有帮助，但它们也有自己的问题，包括以下问题:
- 死锁：两个线程以略微不同的模式请求资源，导致两者都阻塞:
- 优先级反转：高优先级进程等待低优先级慢进程
- 饥饿：一个进程占用一个资源的时间比另一个同样重要的进程长得多

